package main

import (
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"time"

	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/app"
	"fyne.io/fyne/v2/container"
	"fyne.io/fyne/v2/dialog"
	"fyne.io/fyne/v2/widget"
)

type Config struct {
	Account  string `json:"account"`
	Password string `json:"password"`
}

type LoginResponse struct {
	Result   int    `json:"result"`
	JSession string `json:"jsession"`
}

type Device struct {
	VID string `json:"vid"`
	DID string `json:"did"`
}

type StatusResponse struct {
	Result  int      `json:"result"`
	Onlines []Device `json:"onlines"`
}

type VehicleResponse struct {
	Result   int `json:"result"`
	Companys []struct {
		ID   int    `json:"id"`
		Name string `json:"nm"`
		PID  int    `json:"pId"`
	} `json:"companys"`
	Vehicles []struct {
		ID         int    `json:"id"`
		Name       string `json:"nm"`
		PID        int    `json:"pid"`
		PName      string `json:"pnm"`
		DeviceList []struct {
			ID          string `json:"id"`
			Channels    int    `json:"cc"`
			ChanName    string `json:"cn"`
			SIM         string `json:"sim"`
			InstallTime string `json:"ist"`
		} `json:"dl"`
		VehicleType  string `json:"vehiType"`
		VehicleColor string `json:"vehiColor"`
		VehicleBand  string `json:"vehiBand"`
		OwnerName    string `json:"ownerName"`
		EngineNum    string `json:"engineNum"`
		FrameNum     string `json:"frameNum"`
	} `json:"vehicles"`
}

type AlarmResponse struct {
	Result    int `json:"result"`
	AlarmList []struct {
		DevIDNO string `json:"DevIDNO"`
		Desc    string `json:"desc"`
		GUID    string `json:"guid"`
		HD      int    `json:"hd"`
		Img     string `json:"img"`
		Info    int    `json:"info"`
		P1      int    `json:"p1"`
		P2      int    `json:"p2"`
		P3      int    `json:"p3"`
		P4      int    `json:"p4"`
		SrcTm   string `json:"srcTm"`
		StType  int    `json:"stType"`
		Time    string `json:"time"`
		Type    int    `json:"type"`
		Gps     struct {
			DCT  int    `json:"dct"`
			GD   int    `json:"gd"`
			GT   string `json:"gt"`
			HX   int    `json:"hx"`
			Lat  int    `json:"lat"`
			LC   int    `json:"lc"`
			LID  int    `json:"lid"`
			Lng  int    `json:"lng"`
			MLat string `json:"mlat"`
			MLng string `json:"mlng"`
			SP   int    `json:"sp"`
		} `json:"Gps"`
	} `json:"alarmlist"`
	Pagination struct {
		TotalPages   int `json:"totalPages"`
		CurrentPage  int `json:"currentPage"`
		PageRecords  int `json:"pageRecords"`
		TotalRecords int `json:"totalRecords"`
	} `json:"pagination"`
}

const (
	loginURL       = "https://cloud.samsonix.com/StandardApiAction_login.action"
	statusURL      = "https://cloud.samsonix.com/StandardApiAction_getDeviceOlStatus.action"
	liveAPIBaseURL = "https://cloud.samsonix.com/StandardApiAction_realTimeVedio.action"
	vehicleInfoURL = "https://cloud.samsonix.com/StandardApiAction_queryUserVehicle.action"
	alarmURL       = "https://cloud.samsonix.com/StandardApiAction_vehicleAlarm.action"
)

func httpGetJSON(url string) ([]byte, error) {
	client := &http.Client{}
	req, _ := http.NewRequest("GET", url, nil)
	req.Header.Set("User-Agent", "GoClient")

	resp, err := client.Do(req)
	if err != nil && isCertError(err) {
		// Retry with InsecureSkipVerify
		insecureClient := &http.Client{
			Transport: &http.Transport{
				TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
			},
		}
		resp, err = insecureClient.Do(req)
	}
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	return io.ReadAll(resp.Body)
}

func isCertError(err error) bool {
	if err == nil {
		return false
	}
	msg := err.Error()
	return strings.Contains(msg, "x509:") || strings.Contains(msg, "certificate signed by unknown authority")
}

func login(account, password string) (string, error) {
	url := fmt.Sprintf("%s?account=%s&password=%s", loginURL, account, password)
	data, err := httpGetJSON(url)
	if err != nil {
		return "", err
	}
	var res LoginResponse
	if err := json.Unmarshal(data, &res); err != nil {
		return "", err
	}
	if res.Result != 0 {
		return "", fmt.Errorf("login failed (result code %d)", res.Result)
	}
	return res.JSession, nil
}

func getDevices(jsession string) ([]Device, error) {
	//url := fmt.Sprintf("%s?jsession=%s&status=1", statusURL, jsession)
	// Modified to get all devices by removing the status parameter
	url := fmt.Sprintf("%s?jsession=%s", statusURL, jsession)

	data, err := httpGetJSON(url)
	if err != nil {
		return nil, err
	}
	var res StatusResponse
	if err := json.Unmarshal(data, &res); err != nil {
		return nil, err
	}
	return res.Onlines, nil
}

func getVehicleInfo(jsession string) (*VehicleResponse, error) {
	url := fmt.Sprintf("%s?jsession=%s", vehicleInfoURL, jsession)

	// Add debugging
	fmt.Printf("Requesting vehicle info from: %s\n", url)

	data, err := httpGetJSON(url)
	if err != nil {
		fmt.Printf("HTTP request error: %v\n", err)
		return nil, err
	}

	// Debug the raw response
	fmt.Printf("Raw response: %s\n", string(data))

	var res VehicleResponse
	if err := json.Unmarshal(data, &res); err != nil {
		fmt.Printf("JSON parsing error: %v\n", err)
		return nil, err
	}

	if res.Result != 0 {
		fmt.Printf("API error response with code: %d\n", res.Result)
		return nil, fmt.Errorf("vehicle info request failed (result code %d)", res.Result)
	}

	return &res, nil
}

func getDeviceAlarms(jsession, devIDNO string) (*AlarmResponse, error) {
	url := fmt.Sprintf("%s?jsession=%s&DevIDNO=%s&toMap=0", alarmURL, jsession, devIDNO)

	fmt.Printf("Requesting alarms from: %s\n", url)

	data, err := httpGetJSON(url)
	if err != nil {
		fmt.Printf("HTTP request error: %v\n", err)
		return nil, err
	}

	fmt.Printf("Raw alarm response: %s\n", string(data))

	var res AlarmResponse
	if err := json.Unmarshal(data, &res); err != nil {
		fmt.Printf("JSON parsing error: %v\n", err)
		return nil, err
	}

	if res.Result != 0 {
		return nil, fmt.Errorf("alarm request failed (result code %d)", res.Result)
	}

	return &res, nil
}

func generateLinks(jsession, did, vid, account, password string) map[string]string {
	return map[string]string{
		"Web Player ID": fmt.Sprintf("http://cloud.samsonix.com/808gps/open/player/video.html?lang=en&devIdno=%s&account=%s&password=%s", did, account, password),
		"Web Player VI": fmt.Sprintf("http://cloud.samsonix.com/808gps/open/player/video.html?lang=en&vehiIdno=%s&account=%s&password=%s", vid, account, password),
		"Live API":      fmt.Sprintf("%s?jsession=%s&DevIDNO=%s&Chn=1&Sec=300&Label=test", liveAPIBaseURL, jsession, did),
	}
}

func saveToFile(account string, allLinks map[string]map[string]string) error {
	filename := fmt.Sprintf("%s-%ddev-%s.txt", account, len(allLinks), time.Now().Format("2006-01-02"))
	f, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer f.Close()

	for name, links := range allLinks {
		fmt.Fprintf(f, "Device: %s\n", name)
		for k, v := range links {
			fmt.Fprintf(f, "  %s: %s\n", k, v)
		}
		fmt.Fprintln(f, strings.Repeat("-", 60))
	}
	return nil
}

func buildCompanyHierarchy(companies []struct {
	ID   int    `json:"id"`
	Name string `json:"nm"`
	PID  int    `json:"pId"`
}) map[int][]struct {
	ID   int    `json:"id"`
	Name string `json:"nm"`
	PID  int    `json:"pId"`
} {
	hierarchy := make(map[int][]struct {
		ID   int    `json:"id"`
		Name string `json:"nm"`
		PID  int    `json:"pId"`
	})

	for _, company := range companies {
		hierarchy[company.PID] = append(hierarchy[company.PID], company)
	}

	return hierarchy
}

func printCompanyTree(builder *strings.Builder, hierarchy map[int][]struct {
	ID   int    `json:"id"`
	Name string `json:"nm"`
	PID  int    `json:"pId"`
}, parentID int, prefix string) {
	children, exists := hierarchy[parentID]
	if !exists {
		return
	}

	for i, company := range children {
		isLast := i == len(children)-1

		if isLast {
			builder.WriteString(fmt.Sprintf("%s└── %s\n", prefix, company.Name))
			printCompanyTree(builder, hierarchy, company.ID, prefix+"    ")
		} else {
			builder.WriteString(fmt.Sprintf("%s├── %s\n", prefix, company.Name))
			printCompanyTree(builder, hierarchy, company.ID, prefix+"│   ")
		}
	}
}

func appIcon() fyne.Resource {
	iconBytes := []byte{
		0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D,
		0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
		0x08, 0x06, 0x00, 0x00, 0x00, 0x1F, 0x15, 0xC4, 0x89, 0x00, 0x00, 0x00,
		0x0A, 0x49, 0x44, 0x41, 0x54, 0x08, 0xD7, 0x63, 0x00, 0x01, 0x00, 0x00,
		0x05, 0x00, 0x01, 0x0D, 0x0A, 0x2D, 0xB4, 0x00, 0x00, 0x00, 0x00, 0x49,
		0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82,
	}
	return fyne.NewStaticResource("icon.png", iconBytes)
}

func main() {
	myApp := app.New()
	myWindow := myApp.NewWindow("CMSV Video Generator Link")
	myWindow.SetIcon(appIcon())

	accountEntry := widget.NewEntry()
	accountEntry.SetPlaceHolder("Enter Account")
	passwordEntry := widget.NewPasswordEntry()
	passwordEntry.SetPlaceHolder("Enter Password")

	output := widget.NewMultiLineEntry()
	output.SetPlaceHolder("Results will appear here...")
	output.SetMinRowsVisible(15)

	// Create a dropdown for device selection
	deviceSelector := widget.NewSelect([]string{"Login first to see devices"}, func(selected string) {
		// This will be handled when a device is selected
	})
	deviceSelector.PlaceHolder = "Select Device IDNO"
	deviceSelector.Disable() // Disable until logged in

	var allLinks map[string]map[string]string
	var deviceMap map[string]Device // Map to store device names to their IDs
	var jsessionCache string        // Store the session for reuse

	loginBtn := widget.NewButton("Login and Fetch Devices", func() {
		account := strings.TrimSpace(accountEntry.Text)
		password := strings.TrimSpace(passwordEntry.Text)

		if account == "" || password == "" {
			dialog.ShowError(fmt.Errorf("please enter both account and password"), myWindow)
			return
		}

		jsession, err := login(account, password)
		if err != nil {
			dialog.ShowError(fmt.Errorf("Login failed: %v", err), myWindow)
			return
		}

		jsessionCache = jsession // Cache the jsession for later use

		devices, err := getDevices(jsession)
		if err != nil {
			dialog.ShowError(fmt.Errorf("Device fetch failed: %v", err), myWindow)
			return
		}

		// Update the device selector with actual devices
		deviceOptions := []string{"All Devices"}
		deviceMap = make(map[string]Device)

		for _, d := range devices {
			deviceName := fmt.Sprintf("%s (%s)", d.VID, d.DID)
			deviceOptions = append(deviceOptions, deviceName)
			deviceMap[deviceName] = d
		}

		deviceSelector.Options = deviceOptions
		deviceSelector.Enable()
		deviceSelector.SetSelected("All Devices")

		allLinks = make(map[string]map[string]string)
		builder := strings.Builder{}

		builder.WriteString(fmt.Sprintf("Found %d devices\n\n", len(devices)))
		for _, d := range devices {
			key := fmt.Sprintf("%s (%s)", d.VID, d.DID)
			links := generateLinks(jsession, d.DID, d.VID, account, password)
			allLinks[key] = links

			builder.WriteString(fmt.Sprintf("Device: %s\n", key))
			for name, link := range links {
				builder.WriteString(fmt.Sprintf("  %s: %s\n", name, link))
			}
			builder.WriteString(strings.Repeat("-", 60) + "\n")
		}

		output.SetText(builder.String())
	})

	saveBtn := widget.NewButton("Save to File", func() {
		if allLinks == nil {
			dialog.ShowInformation("Info", "No data to save yet", myWindow)
			return
		}
		err := saveToFile(accountEntry.Text, allLinks)
		if err != nil {
			dialog.ShowError(err, myWindow)
		} else {
			dialog.ShowInformation("Success", "File saved successfully", myWindow)
		}
	})

	vehicleInfoBtn := widget.NewButton("VEHICLE INFORMATION", func() {
		account := strings.TrimSpace(accountEntry.Text)
		password := strings.TrimSpace(passwordEntry.Text)

		if account == "" || password == "" {
			dialog.ShowError(fmt.Errorf("please enter both account and password"), myWindow)
			return
		}

		jsession, err := login(account, password)
		if err != nil {
			dialog.ShowError(fmt.Errorf("Login failed: %v", err), myWindow)
			return
		}

		jsessionCache = jsession // Cache the jsession for reuse
		fmt.Printf("Using jsession: %s\n", jsession)

		vehicleInfo, err := getVehicleInfo(jsession)
		if err != nil {
			dialog.ShowError(fmt.Errorf("Vehicle info fetch failed: %v", err), myWindow)
			return
		}

		builder := strings.Builder{}

		// Build and display company hierarchy as a clean tree without IDs
		builder.WriteString("=== COMPANY HIERARCHY ===\n")
		hierarchy := buildCompanyHierarchy(vehicleInfo.Companys)
		printCompanyTree(&builder, hierarchy, 2, "")
		builder.WriteString("\n")

		// Display vehicle information
		builder.WriteString("=== VEHICLE INFORMATION ===\n")
		for _, vehicle := range vehicleInfo.Vehicles {
			builder.WriteString(fmt.Sprintf("Vehicle: %s (ID: %d)\n", vehicle.Name, vehicle.ID))
			builder.WriteString(fmt.Sprintf("  Company: %s\n", vehicle.PName))
			builder.WriteString(fmt.Sprintf("  Type: %s, Band: %s, Color: %s\n",
				vehicle.VehicleType, vehicle.VehicleBand, vehicle.VehicleColor))
			builder.WriteString(fmt.Sprintf("  Owner: %s\n", vehicle.OwnerName))
			builder.WriteString(fmt.Sprintf("  Engine #: %s, Frame #: %s\n",
				vehicle.EngineNum, vehicle.FrameNum))

			// Display device information for each vehicle
			builder.WriteString("  Devices:\n")
			for _, device := range vehicle.DeviceList {
				builder.WriteString(fmt.Sprintf("    Device ID: %s\n", device.ID))
				builder.WriteString(fmt.Sprintf("    Channels: %d (%s)\n",
					device.Channels, device.ChanName))
				builder.WriteString(fmt.Sprintf("    SIM: %s\n", device.SIM))
				builder.WriteString(fmt.Sprintf("    Install Time: %s\n", device.InstallTime))
			}
			builder.WriteString(strings.Repeat("-", 60) + "\n")
		}

		output.SetText(builder.String())
	})

	alarmBtn := widget.NewButton("GET DEVICE ALARMS", func() {
		if jsessionCache == "" {
			dialog.ShowError(fmt.Errorf("please login first"), myWindow)
			return
		}

		selectedDevice := deviceSelector.Selected
		if selectedDevice == "" {
			dialog.ShowError(fmt.Errorf("please select a device"), myWindow)
			return
		}

		// Get the device ID based on selection
		var deviceID string
		if selectedDevice == "All Devices" {
			deviceID = "" // Empty string means all devices
		} else {
			deviceID = deviceMap[selectedDevice].DID
		}

		alarmData, err := getDeviceAlarms(jsessionCache, deviceID)
		if err != nil {
			dialog.ShowError(fmt.Errorf("alarm fetch failed: %v", err), myWindow)
			return
		}

		builder := strings.Builder{}
		builder.WriteString("=== DEVICE ALARMS ===\n")

		if len(alarmData.AlarmList) == 0 {
			builder.WriteString("No alarms found for this device\n")
		} else {
			builder.WriteString(fmt.Sprintf("Found %d alarms\n\n", len(alarmData.AlarmList)))

			for _, alarm := range alarmData.AlarmList {
				builder.WriteString(fmt.Sprintf("Device: %s\n", alarm.DevIDNO))
				builder.WriteString(fmt.Sprintf("Time: %s\n", alarm.Time))
				builder.WriteString(fmt.Sprintf("Type: %d\n", alarm.Type))
				builder.WriteString(fmt.Sprintf("Description: %s\n", alarm.Desc))

				if alarm.Gps.Lat != 0 && alarm.Gps.Lng != 0 {
					builder.WriteString(fmt.Sprintf("Location: %.6f, %.6f\n",
						float64(alarm.Gps.Lat)/1000000.0,
						float64(alarm.Gps.Lng)/1000000.0))
					builder.WriteString(fmt.Sprintf("Mapped Location: %s, %s\n",
						alarm.Gps.MLat, alarm.Gps.MLng))
					builder.WriteString(fmt.Sprintf("Speed: %.1f km/h\n", float64(alarm.Gps.SP)/10.0))
				}

				if alarm.HD == 1 {
					builder.WriteString("Status: Processed\n")
				} else {
					builder.WriteString("Status: Unprocessed\n")
				}

				builder.WriteString(strings.Repeat("-", 60) + "\n")
			}
		}

		output.SetText(builder.String())
	})

	// Update window content with device dropdown instead of text entry
	myWindow.SetContent(container.NewVBox(
		widget.NewLabel("Samsonix API Generator"),
		accountEntry,
		passwordEntry,
		deviceSelector,
		container.NewHBox(
			loginBtn,
			saveBtn,
			vehicleInfoBtn,
			alarmBtn,
		),
		output,
	))

	myWindow.Resize(fyne.NewSize(700, 600))
	myWindow.ShowAndRun()
}
